#!/usr/bin/env python
PACKAGE = "cob_twist_controller"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
hardware_interface_enum = gen.enum([ 
                       gen.const("VELOCITY_INTERFACE",      int_t, 0, "Use VelocityJointInterface. Requires velocity_controllers/joint_group_velocity_controller"),
                       gen.const("POSITION_INTERFACE",      int_t, 1, "Use PositionJointInterface. Requires position_controllers/joint_group_position_controller")],
                     "enum types for the hardware interface types")

damping_method_enum = gen.enum([ 
                       gen.const("NO_DAMPING",           int_t, 0, "No damping means a damping factor of 0.0."),
                       gen.const("CONSTANT",             int_t, 1, "Constant damping factor given by parameter damping_factor."), 
                       gen.const("MANIPULABILITY",       int_t, 2, "Damping factor calculation based on the manipulability measure."), 
                       gen.const("LEAST_SINGULAR_VALUE", int_t, 3, "Damping factor calculation based on the least singular value")],
                     "enum types for the damping_method")

constraints_enum = gen.enum([ 
                       gen.const("NO_CONSTRAINT",     int_t, 0, "No constraints active"),
                       gen.const("WLN",               int_t, 1, "Weighted-least-norm base, with identity as weighting matrix (equal to None)"),
                       gen.const("WLN_JLA",           int_t, 2, "Weighted-least-norm joint-limit-avoidance"), 
                       gen.const("GPM_JLA",           int_t, 3, "Gradient-projection-method joint-limit-avoidance"), 
                       gen.const("GPM_JLA_MID",       int_t, 4, "Gradient-projection-method joint-limit-avoidance to keep middle"), 
                       gen.const("GPM_CA",            int_t, 5, "Gradient-projection-method collision avoidance"),
                       gen.const("TASK_STACK_NO_GPM", int_t, 6, "Stack of tasks with highest prio Collision Avoidance"),
                       gen.const("TASK_STACK_GPM",    int_t, 7, "Stack of tasks with deactivation of several tasks"),
                       gen.const("TASK_2ND_PRIO",     int_t, 8, "Task Priority Strategy for obstacle avoidance ..."),
                       gen.const("DYN_TASKS_READJ",   int_t, 9, "Task Priority Strategy for all with dynamic resadjust of GPM and task ..."),
                       ],
                     "enum types for the constraints")

kinematic_extension_enum = gen.enum([ 
                       gen.const("NO_EXTENSION",      int_t, 0, "No additional DoF considered"),
                       gen.const("BASE_ACTIVE",       int_t, 1, "Consider additoinal DoF of a mobile base (2d)")],
                     "enum types for the hardware interface types")

gen.add("hardware_interface_type",     int_t,    0, "The hardware interface to use", 0, None, None, edit_method=hardware_interface_enum)
gen.add("numerical_filtering",         bool_t,   0, "Numerical Filtering yes/no",  False)
gen.add("damping_method",              int_t,    0, "The damping method to use.", 2, None, None, edit_method=damping_method_enum)
gen.add("damping_factor",     double_t, 0, "The constant damping_factor (used in CONSTANT)",  0.01, 0, 1)
gen.add("lambda_max",         double_t, 0, "Value for maximum damping_factor (used in MANIPULABILITY/LSV)",  0.1, 0, 10)
gen.add("w_threshold",        double_t, 0, "Value for manipulability threshold (used in MANIPULABILITY)",  0.005, 0, 1)
gen.add("beta",               double_t, 0, "Beta for Low Isotropic Damping",  0.005, 0, 1)
gen.add("eps_damping",        double_t, 0, "Value for least singular value damping",  0.003, 0,   1)

gen.add("constraint",         int_t,    0, "The constraint to use (edited via an enum)", 2, None, None, edit_method=constraints_enum)

gen.add("eps_truncation",     double_t, 0, "Value for singular value threshold (used for truncation: sing. value < eps)",    0.03, 0,   1)

gen.add("mu"                 ,double_t, 0, "Transition smoothness", -2.0, -1000.0, 1000.0)
gen.add("k_H",                double_t, 0, "Self-motion factor for GPM", -10.0, -1000,   1000)

gen.add("keep_direction",     bool_t,   0, "With keep_direction the whole joint positions and velocities vector is affected by a scaling factor. Else only individual components of the vectors are affected -> direction will be changed.", True)
gen.add("enforce_vel_limits", bool_t,   0, "If 'True', enforce joint velocity limits in TwistController, else let RobotHW handle the limits",  True)
gen.add("enforce_pos_limits", bool_t,   0, "If 'True', enforce joint position limits in TwistController, else let RobotHW handle the limits",  True)
gen.add("tolerance",          double_t, 0, "Tolerance around joint position limits where velocities are normalized [degrees]",  5, 0, 15)

gen.add("base_compensation",      bool_t,   0, "Compensate base motion",  False)
gen.add("kinematic_extension",    int_t,    0, "Consider additional DoF", 0, None, None, edit_method=kinematic_extension_enum)
gen.add("base_ratio",             double_t, 0, "Value for base_ratio",  0.0, 0, 1)

exit(gen.generate(PACKAGE, "cob_twist_controller", "TwistController"))
