// ROS message includes
#include "ros/ros.h"
#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/JointState.h>

/* protected region user include files on begin */
// read x_target (X_soll):
#include <tf/transform_listener.h>
#include <geometry_msgs/TransformStamped.h>
#include <cob_srvs/SetString.h>
#include <std_srvs/Empty.h>
#include <kdl_parser/kdl_parser.hpp>
#include <kdl/chainiksolvervel_pinv.hpp>
#include <kdl/chainfksolvervel_recursive.hpp>
#include <kdl/jntarray.hpp>
#include <kdl/jntarrayvel.hpp>
#include <math.h>
//#include <Eigen/Dense>
//#include <Eigen/SVD>
/* protected region user include files end */

class cob_twist_action_config
{
public:
    double x_dot_max_deviation_lin;
    std::string target_tracking_frame;
    double x_dot_max_deviation_rot;
};

class cob_twist_action_data
{
// autogenerated: don't touch this class
public:
    //input data
    geometry_msgs::Twist in_twist_command;
    sensor_msgs::JointState in_joint_state_reader;
    //output data
    geometry_msgs::Twist out_twist_action;
    bool out_twist_action_active;
};

class cob_twist_action_impl
{
    /* protected region user member variables on begin */
	cob_twist_action::TwistFeedback feedback_;
	cob_twist_action::TwistResult result_;
	cob_twist_action::TwistGoal test_goal;


	// -----------------------------------
	bool successfully_initialized_;
	ros::NodeHandle nh_main;
	std::vector<double> transform_distance_;
	std::vector<double> twist_abs_;
	geometry_msgs::Twist control_error_;
	bool twist_action_working_;
	bool frame_tracker_working_;
	bool twist_controller_working_;
	bool twist_controller_stuck_;
	// -----------------------------------
//	geometry_msgs::Twist input_twist;
	std::string action_name_;
	double max_deviation_;
	int sendoutput;

	// read x_target (X_soll):
	ros::NodeHandle service_client;
	std::string active_frame_;
	std::string tracking_frame_;
	tf::StampedTransform transform_tf;
	geometry_msgs::TransformStamped transform_msg;
	geometry_msgs::Twist twist_msg;
	tf::TransformListener tf_listener_;
	// read x_dot_target
	geometry_msgs::Twist target_twist_;


	/// KDL Conversion
	KDL::Chain chain_;
	KDL::JntArray q_temp;
	KDL::JntArray q_dot_temp;
	KDL::JntArray last_q_;
	KDL::JntArray last_q_dot_;
	std::vector<std::string> joints_;
	KDL::ChainFkSolverVel_recursive* jntToCartSolver_vel_;
	unsigned int dof_;
	KDL::Vector vector_vel_,vector_rot_;
    /* protected region user member variables end */

public:
    cob_twist_action_impl() 
    {
        /* protected region user constructor on begin */
    	successfully_initialized_ = false;

    	twist_action_working_ = false;
    	frame_tracker_working_ = false;
    	twist_controller_working_ = false;
    	twist_controller_stuck_ = false;
//    	transform_distance_.push_back(0);
//    	transform_distance_.push_back(0);
    	// read x_target (X_soll):
    	// read out of yaml for each controller!
    	// /opt/ros/indigo/share/cob_controller_configuration_gazebo/controller/torso/torso_controller_cob4_velocityinterfaces.yaml
		active_frame_ = "torso_center_link";
		tracking_frame_ = "torso_center_target";
    	// zeug von Manfred:
    	// subscriber for joint states noch einfÃ¼gen!!!
    	///parse robot_description and generate KDL chains


    	//End Zeug von Manfred
		ROS_INFO("constructor finished successfully!");
    	/* protected region user constructor end */
    }

    void configure(cob_twist_action_config config) 
    {
        /* protected region user configure on begin */
    	ROS_INFO("reading config ...");
    	sendoutput = 1;
    	// read x_target (X_soll):
    	config.target_tracking_frame = tracking_frame_;

    	// initialize once:
    	if (!successfully_initialized_) {
    		if (initialize()) {
    			successfully_initialized_ = true;
    		}
    	}

		// JointNames
		// Back to initialize() better !!!

		ROS_INFO("config finished successfully!");
    	/* protected region user configure end */
    }

    void update(cob_twist_action_data &data, cob_twist_action_config config)
    {
        /* protected region user update on begin */
    	transform_distance_.clear();
    	twist_abs_.clear();
//    	ROS_INFO("I'm performing an update --- simulation");
//    	ROS_INFO("received data: ");
    	//new command_twist in --> data.in_twist_command ...
    	data.out_twist_action = data.in_twist_command;
//    	if (sendoutput < 50) {
//    		sendoutput++;
//
//    		data.out_twist_action_active = true;
//    	}
//    	else {
//    		data.out_twist_action.linear.x = 10.0;
//    		data.out_twist_action_active = false;
//    	}


    	// read x_target, x_current (X_soll, X_ist) = x_transform:
    	if (successfully_initialized_) {
    		bool transform_available = false;
    		while (!transform_available) {
    			try {
					tf_listener_.lookupTransform(active_frame_, tracking_frame_, ros::Time(0), transform_tf);
				}
				catch (tf::TransformException te) {
					ROS_WARN("Waiting for transform ...");
					if (ros::isShuttingDown()) {
						break;
					}
					ros::Duration(0.5).sleep();
					continue;
				}
//				catch (tf::ConnectivityException ce) {
//					ROS_WARN("Waiting for transform ...");
//					if (ros::isShuttingDown()) {
//						break;
//					}
//					ros::Duration(0.5).sleep();
//					continue;
//				}
//				catch (tf::ExtrapolationException ee) {
//					ROS_WARN("Waiting for transform ...");
//					if (ros::isShuttingDown()) {
//						break;
//					}
//					ros::Duration(0.5).sleep();
//					continue;
//				}
				transform_available = true;

			}
//    		ROS_INFO("Init transform from target %s to %s successfully received!", active_frame_.c_str() , tracking_frame_.c_str());


			tf::transformStampedTFToMsg(transform_tf, transform_msg);
			double eukl_dist_lin = sqrt (transform_msg.transform.translation.x * transform_msg.transform.translation.x + transform_msg.transform.translation.y * transform_msg.transform.translation.y + transform_msg.transform.translation.z * transform_msg.transform.translation.z);
			KDL::Rotation q;
			q = KDL::Rotation::Quaternion(transform_msg.transform.rotation.x, transform_msg.transform.rotation.y, transform_msg.transform.rotation.z, transform_msg.transform.rotation.w);
			transform_distance_.push_back(eukl_dist_lin);
			double roll, pitch, yaw;
			q.GetRPY(roll,pitch,yaw);
			double eukl_dist_rot = sqrt (roll * roll + pitch * pitch + yaw* yaw);
			transform_distance_.push_back(eukl_dist_rot);
//			ROS_INFO("x_transform:[%f,%f,%f,%f,%f,%f,%f]",transform_msg.transform.translation.x, transform_msg.transform.translation.y, transform_msg.transform.translation.z, transform_msg.transform.rotation.x, transform_msg.transform.rotation.y, transform_msg.transform.rotation.z, transform_msg.transform.rotation.w);
//			ROS_INFO("x_eukl_dist:[%f,%f]", transform_distance_.at(0), transform_distance_.at(1));
			if (transform_distance_.at(0) > 0.01 | transform_distance_.at(1) > 0.01) {
				frame_tracker_working_ = true;
			}
			else {
				frame_tracker_working_ = false;
			}


			// read x_dot_target:
			target_twist_ = data.in_twist_command;

			// read x_dot current:
			int count = 0;

			for(unsigned int j = 0; j < dof_; j++)
			{   //msg->name.size()
				//ROS_INFO("data name at j = %s",data.in_joint_state_reader.name.at(j).c_str());
				for(unsigned int i = 0; i < data.in_joint_state_reader.name.size(); i++)
				{ // msg->name[i]
					if(strcmp(data.in_joint_state_reader.name.at(i).c_str(), joints_[j].c_str()) == 0)
					{ // msg->position[i]
						q_temp(j) = data.in_joint_state_reader.position.at(i);
						q_dot_temp(j) = data.in_joint_state_reader.velocity.at(i); // msg->velocity[i]
						count++;
						break;
					}
				}
			}

			if(count == joints_.size())
			{
				KDL::FrameVel FrameVel;
				last_q_ = q_temp;
				last_q_dot_ = q_dot_temp;
				KDL::JntArrayVel jntArrayVel = KDL::JntArrayVel(last_q_,last_q_dot_);
				jntToCartSolver_vel_ = new KDL::ChainFkSolverVel_recursive(chain_);
				int ret = jntToCartSolver_vel_->JntToCart(jntArrayVel,FrameVel,-1);
				if(ret>=0){
					KDL::Twist twist = FrameVel.GetTwist();
					vector_vel_ = twist.vel;
					vector_rot_ = twist.rot;
				}
				else{
					ROS_WARN("ChainFkSolverVel failed!");
				}
			}
//			ROS_INFO("x_dot_target = [%f,%f,%f,%f,%f,%f]",data.in_twist_command.linear.x, data.in_twist_command.linear.y, data.in_twist_command.linear.z, data.in_twist_command.angular.x, data.in_twist_command.angular.y, data.in_twist_command.angular.z);
//			ROS_INFO("x_dot_current = [%f,%f,%f,%f,%f,%f]", vector_vel_.x(), vector_vel_.y(), vector_vel_.z(), vector_rot_.x(), vector_rot_.y(), vector_rot_.z());
			// x_dot_target - x_dot_current ...
			control_error_.linear.x = data.in_twist_command.linear.x - vector_vel_.x();
			control_error_.linear.y = data.in_twist_command.linear.y - vector_vel_.y();
			control_error_.linear.z = data.in_twist_command.linear.z - vector_vel_.z();
			control_error_.angular.x = data.in_twist_command.angular.x - vector_rot_.x();
			control_error_.angular.y = data.in_twist_command.angular.y - vector_rot_.y();
			control_error_.angular.z = data.in_twist_command.angular.z - vector_rot_.z();
//			ROS_INFO("control_error diff = [%f,%f,%f,%f,%f,%f]",control_error_.linear.x, control_error_.linear.y ,control_error_.linear.z ,control_error_.angular.x, control_error_.angular.y, control_error_.angular.z );
			double abs_control_error_lin = sqrt(control_error_.linear.x * control_error_.linear.x + control_error_.linear.y * control_error_.linear.y + control_error_.linear.z * control_error_.linear.z);
			double abs_control_error_rot = sqrt(control_error_.angular.x * control_error_.angular.x + control_error_.angular.y * control_error_.angular.y + control_error_.angular.z * control_error_.angular.z);
			twist_abs_.push_back(abs_control_error_lin);
			twist_abs_.push_back(abs_control_error_rot);
//			ROS_INFO("abs_contr_err_lin [%f,%f]",twist_abs_.at(0), twist_abs_.at(1));
			if (twist_abs_.at(0) > config.x_dot_max_deviation_lin | twist_abs_.at(1) > config.x_dot_max_deviation_rot) {
				twist_controller_stuck_ = true;
			}
    	}
    	else
    		ROS_ERROR(".................  Initializing failed! ..................");

    	//ROS_INFO(data.cob_twist_action_data);
		ROS_INFO("user update finished successfully!");
        /* protected region user update end */
    }


    void callback_perform_twist_(const cob_twist_action::TwistGoalConstPtr &goal, actionlib::SimpleActionServer<cob_twist_action::TwistAction> *as_)
    {
        /* protected region user implementation of action callback for perform_twist on begin */
        // helper variables
        ros::Rate r(1);
        bool success = false;
        ROS_INFO("tracking is = %s", goal->tracking ? "true":"false");
        ROS_INFO("flag 0");
//        ROS_INFO("trafo_dist %f, %f ", transform_distance_.at(0),  transform_distance_.at(1));
        ROS_INFO("flag 0.1");
//        feedback_.transform_distance.push_back(transform_distance_.at(0));
//        feedback_.transform_distance.push_back(transform_distance_.at(1));
        feedback_.transform_distance.push_back(1.0);
        ROS_INFO("flag 1");
        as_->publishFeedback(feedback_);
        ROS_INFO("flag 2");
        twist_action_working_ = goal->tracking;
        if (twist_action_working_) {
        	ROS_INFO("twist action is working ...");
//        	as_->setPreempted();
        }
        else {
        	ROS_INFO("twist action stopped ...");
        }

//        if (as_->isPreemptRequested()) {
//        	ROS_INFO("server is preemptRequested");
//        }
        if (twist_controller_stuck_) {
        	result_.success = false;
        	as_->setAborted(result_, "Twist_Controller stuck --> Action aborted!");

        }
//        input_twist = goal->twist_goal;
        //publish info for user ...
//        ROS_INFO("x_dot_target:[%f,%f,%f,%f,%f,%f]", goal->twist_goal.linear.x, goal->twist_goal.linear.y, goal->twist_goal.linear.z, goal->twist_goal.angular.x, goal->twist_goal.angular.y, goal->twist_goal.angular.z);
//        ROS_INFO("Trying to reach goal: Twist:[%f,%f,%f,%f,%f,%f]", goal->twist_goal.linear.x, goal->twist_goal.linear.y, goal->twist_goal.linear.z, goal->twist_goal.angular.x, goal->twist_goal.angular.y, goal->twist_goal.angular.z);
        // start executing the action
        ///action action action (Twist Controller) ... in loop! //<
        // check that preempt has not been requested by the client
//        for (int i = 1; i< 400; i++) {
//        	if (as_->isPreemptRequested() || !ros::ok())
//			{
//				ROS_INFO("%s: Preempted", action_name_.c_str());
//				// set the action state to preempted
//				as_->setPreempted();
//				success = false;
//				break;
//			}
////			feedback_.current_twist = input_twist;
////			as_->publishFeedback(feedback_);
//			r.sleep();
//        }
        feedback_.transform_distance.push_back(1.0);
		ROS_INFO("flag 1");
		as_->publishFeedback(feedback_);
		r.sleep();
//        while (twist_action_working_) {
//        	feedback_.transform_distance.push_back(1.0);
//			ROS_INFO("flag 1");
//			as_->publishFeedback(feedback_);
//			ROS_INFO("as_->isActive() %s", as_->isActive() ? "true":"false");
//			r.sleep();
////			if (as_->isActive()) {
//////				as_->setAborted(result_, "Twist_Controller stuck --> Action aborted!");
////			}
//
////			if () {
////				as_->
////				as_->setAborted(result_, "Twist_Controller stuck --> Action aborted!");
////			}
//
//        }
//        as_->setAborted(result_, aborted_text);
    	//> end of action loop
    	if(success)
    	{
    		result_.success = success;
//    		result_.result_twist = input_twist; // just for now
    		ROS_INFO("%s: Succeeded", action_name_.c_str());
    		// set the action state to succeeded
    		as_->setSucceeded(result_);
//    		ros::ServiceClient client = service_client.serviceClient<cob_srvs::SetString>("/torso/start_tracking");
//    		cob_srvs::SetString srv;
//    		srv.request.data =  tracking_frame_;
//			if (client.call(srv)) {
//				//std::stringstream ss;
//				//ss << "Lookat odometry target started with frame: " << config.lookat_frame_id;
//				ROS_INFO("torso target started with frame: %s",  tracking_frame_.c_str());
//			}
//			else {
//				std::stringstream ss;
//				ss << "Server call torso target start failed! Frame: " <<  tracking_frame_;
//				ROS_ERROR("%s",ss.str().c_str());
//			}
    	}

    	ROS_INFO("action callback finished successfully!");
        /* protected region user implementation of action callback for perform_twist end */
    }
    /* protected region user additional functions on begin */
    bool initialize() {
    	KDL::Tree my_tree;
		std::string robot_desc_string;
    	ros::NodeHandle nh_cartesian("cartesian_controller");
    	ros::NodeHandle nh_base("base");
    	std::string chain_base_;
    	std::string chain_tip_;
		///parse robot_description and generate KDL chains
		nh_main.param("/robot_description", robot_desc_string, std::string());
		//ROS_INFO("%s",robot_desc_string.c_str());
		if (!kdl_parser::treeFromString(robot_desc_string, my_tree)){
			ROS_ERROR("Failed to construct kdl tree");
			return false;
		}

		if(!nh_main.getParam("joint_names", joints_))
		{
			ROS_ERROR("Parameter 'joint_names' not set");
			return false;
		}
		dof_ = joints_.size();

		// Chain
		if(!nh_cartesian.getParam("base_link", chain_base_))
		{
			ROS_ERROR("Parameter 'base_link' not set");
			return false;
		}
		if (!nh_cartesian.getParam("tip_link", chain_tip_))
		{
			ROS_ERROR("Parameter 'tip_link' not set");
			return false;
		}

		my_tree.getChain(chain_base_, chain_tip_, chain_);
		if(chain_.getNrOfJoints() == 0)
		{
			ROS_ERROR("Failed to initialize kinematic chain");
			return false;
		}



		//initialize variables and current joint values and velocities

		last_q_ = KDL::JntArray(chain_.getNrOfJoints());
		last_q_dot_ = KDL::JntArray(chain_.getNrOfJoints());
		q_temp = last_q_;
		q_dot_temp = last_q_dot_;
		successfully_initialized_ = true;
    }
    /* protected region user additional functions end */
};
